
/////////////////////////////// 8INF854 - ARCHITECTURES PARRALLELES - DEVOIR #3 ////////////////////////////////////////
///////////////////////////// tri tableau MPI - Corentin RAOULT - Adrien Cambillau /////////////////////////////////////

//http://www.cac.cornell.edu/vw/MPIoneSided/exercise.aspx

#include <stdio.h>
#include <stdlib.h>
#include <mpi.h>
#include <time.h>

#define BLOCK_LOW(id,p,n)  ((id)*(n)/(p))

#define BLOCK_HIGH(id,p,n) \
(BLOCK_LOW((id)+1,p,n)-1)

#define BLOCK_SIZE(id,p,n) \
(BLOCK_LOW((id)+1,p,n)-BLOCK_LOW(id,p,n))

#define BLOCK_OWNER(index,p,n) \
(((p)*(index)+1)-1)/(n))


struct tableau
{
	int * tab;
	int taille;
};

//variable globale sale accessible de partout
MPI_Win window1;

////////////////////// déclaration des fonctions ////////////////////////////////////////////////////////////////////

int demandeNombre();
void remplirTABrand( struct tableau T);

struct tableau TD_init(int n);
int TD_get(struct tableau T, int i, int *x);
int TD_put(struct tableau T, int i, int x);
int TD_somme(struct tableau T); // Retourne la somme des  éléments de T .
void TD_afficher(struct tableau T,int i, int j); // Affiche dans l’ordre les  éléments i (i ≤ j) du tableau T .
void afficherNomMachine();

int partition(int * a, int p, int r);
void quicksort(int * a, int p, int r);

///////////////////// MAIN ///////////////////////////////////////////////////////////////////////////////////

int main (int argc, char **argv) 
{
	int n = atoi(argv[1]);

    int rank, i;

    //Start up MPI...
    MPI_Init(&argc,&argv);
    MPI_Comm_rank(MPI_COMM_WORLD,&rank);
    MPI_Comm comm;
    MPI_Group comm_group, group;
    MPI_Win win;
    comm = MPI_COMM_WORLD;

    
	struct tableau T;
	T.tab = calloc(n, sizeof(int));//Initialize all buffers to 0

    if (rank == 0) {
        /* Only rank 0 has a nonzero buffer at start */
        T = TD_init(n);
        /* Everyone will retrieve from the buffer on root */
        int soi = sizeof(int);
        MPI_Win_create(T.tab,soi*n,soi,MPI_INFO_NULL,comm,&win);
    }
    else {
        /* Others only retrieve, so these windows can be size 0 */
        MPI_Win_create(NULL,n*sizeof(int),sizeof(int),MPI_INFO_NULL,comm,&win);
    }
    printf("Before Get on %d:	\n",rank);
    for(i=0;i<n;i++)printf("%d    ", T.tab[i]);
    	printf("\n\n");

    /* No local operations prior to this epoch, so give an assertion */
    MPI_Win_fence(MPI_MODE_NOPRECEDE,win);

    /* Inside the fence, ranks make RMA calls to GET from rank 0 */
    if (rank != 0) {
        MPI_Get(T.tab,n,MPI_INT,0,0,n,MPI_INT,win);
    }

    /* Complete the epoch - this blocks until the MPI_Get is complete -
       all done with the window, so tell MPI there are no more epochs */
    MPI_Win_fence(MPI_MODE_NOSUCCEED,win);

    printf("After Get on %d:\n",rank);
 		for(i=0;i<n;i++)printf("%d    ", T.tab[i]);
 			printf("\n\n");
    /* Free up our window */
    MPI_Win_free(&win);

    //Shut down...
    MPI_Finalize();
    return(0);
}


/////////////////// développement des fonctions /////////////////////////////////////////////////////////////

int demandeNombre()
{
	int i; char buf[128] = {0};
	//tant que l'entrée n'est pas correcte on la redemande
	while(scanf("%d", &i) != 1)
	{
		scanf("%s", &buf);
		printf("Désolé, [%s] n'est pas un nombre, veuillez taper une valeur correcte : ", &buf);
	}
	return i;
}

void afficherNomMachine()
{
	char hostname[256]; 

	if (gethostname(hostname, sizeof(hostname)) == 0) 
	{
		printf("%s\n", hostname);fflush(stdout);
	}
	else 
		fprintf(stderr, "La fonction gethostname a echoue.\n");
}

void remplirTABrand(struct tableau T)
{
	int i;
	srand(time(NULL));
	for(i=0;i<T.taille;i++)
		T.tab[i] = rand()%T.taille; //limité par unsigned long long int
}

struct tableau TD_init(int n)
{
	struct tableau T;
	T.tab =  malloc(n*sizeof(int));
	T.taille=n;

	remplirTABrand(T);

	//http://www.ucs.cam.ac.uk/docs/course-notes/unix-courses/MPI/files/paper_13.pdf

	printf("Tableau original\n");fflush(stdout);
	TD_afficher(T,0, T.taille);fflush(stdout);

	return T;
}


int TD_get(struct tableau T, int i, int *x)
{
	if(i < T.taille)
	{
		//*x = *(T.tab + i);
		/*MPI_PUT (void *origin_addr, int origin_count, MPI_Datatype
			origin_datatype, int target_rank, MPI_Aint target_disp, int
			target_count, MPI_Datatype
			target_datatype, MPI_Win
			window, ierr);*/

			/*printf("tab actuel, i=%d\n",i);
	 		TD_afficher(T,0, T.taille);
	 		printf("T+i[%d]=%d\n",i,T.tab[i]);*/



	 		MPI_Win_fence(0, window1);	
	 		MPI_Get (x, 1, MPI_INT,0, *(T.tab+0), 1, MPI_INT, window1);	
	 		MPI_Win_fence(0, window1);	


	 		return 1;
	 	}
	 	else
	 	{
	 		return 0;
	 	}

	 }

	 int TD_put(struct tableau T, int i, int x)
	 {
	 	if(i < T.taille)
	 	{
	 		T.tab[i] = x;
		//error = MPI_Put(T.tab, T.taille, MPI_INT, i, T.taille, MPI_INT, window);

	 		return 1;
	 	}
	 	else
	 	{
	 		return 0;
	 	}
	 }

	 int TD_somme(struct tableau T)
	 {
	 	int i;
	 	int somme=0;
	 	for(i=0;i<T.taille;i++)
	 	{
	 		somme+=T.tab[i];
	 	}
	 	return somme;
	 }


	 void TD_afficher(struct tableau T,int i, int j)
	 {
	 	int c;
	 	printf("tab: {");
	 	for(c=i;c<j;c++)
	 	{
	 		printf(" %d ", T.tab[c]);
	 	}
	 	printf("}\n");
	 }




	 int partition(int * a, int p, int r)
	 {
	 	int lt[r-p];
	 	int gt[r-p];
	 	int i;
	 	int j;
	 	int key = a[r];
	 	int lt_n = 0;
	 	int gt_n = 0;

	#pragma omp parallel for
	 	for(i = p; i < r; i++){
	 		if(a[i] < a[r]){
	 			lt[lt_n++] = a[i];
	 		}else{
	 			gt[gt_n++] = a[i];
	 		}   
	 	}   

	 	for(i = 0; i < lt_n; i++){
	 		a[p + i] = lt[i];
	 	}   

	 	a[p + lt_n] = key;

	 	for(j = 0; j < gt_n; j++){
	 		a[p + lt_n + j + 1] = gt[j];
	 	}   

	 	return p + lt_n;
	 }

	 void quicksort(int * a, int p, int r)
	 {
	 	int div;

	 	if(p < r){ 
	 		div = partition(a, p, r); 
		#pragma omp parallel sections
	 		{   
			#pragma omp section
	 			quicksort(a, p, div - 1); 
			#pragma omp section
	 			quicksort(a, div + 1, r); 
	 		}
	 	}
	 }
